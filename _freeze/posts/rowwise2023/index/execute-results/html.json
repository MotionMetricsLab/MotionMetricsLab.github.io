{
  "hash": "b3b67acf4e75736fed076d6c7c77af12",
  "result": {
    "markdown": "---\ntitle: \"Row-wise means in dplyr\"\ndescription: \"Guide to calculating mean scores in dplyr\"\nauthor: \"Jeffrey Girard\"\ndate: \"2023-03-18\"\nimage: pexels159519.webp\ndraft: false\ncategories:\n  - teaching\n  - data science\n---\n\n\n## TL;DR\n\nFor those looking for a quick answer, here is an example of my recommended approach, which calculates a new variable, the mean fuel efficiency (`mfe`) of each car, as the row-wise mean of two existing variables, highway fuel efficiency (`hwy`) and city fuel efficiency (`cty`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # needs dplyr version 1.1.0+\n\n# Calculate mean fuel efficiency (mfe) from highway (hwy) and city (cty)\nmpg |> mutate(mfe = rowMeans(pick(hwy, cty)))\n```\n:::\n\n\n\n## Introduction\n\n[dplyr](https://dplyr.tidyverse.org/) is an amazing tool for data wrangling and I use it daily. However, there is one type of operation that I frequently do that has historically caused me some confusion and frustration: row-wise means. Once I figured out what was going on, I wanted to share what I learned through this brief blog post. It will focus on how to avoid some common issues I ran into and how to speed up rowwise operations with large data frames. I hope some find it helpful. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages used in this post\nlibrary(tidyverse)\nlibrary(microbenchmark)\n\n# Set random seed for reproduciblity\nset.seed(2023)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Simulated Example Data\n\nLet's say we have a tibble (or data frame) containing 10 observations and 4 numerical variables: `y`, `x1`, `x2`, and `x3`. We can simulate this quickly using `rnorm()` to sample from different normal distributions.\n\n\n::: {.cell df-print='kable'}\n\n```{.r .cell-code}\n# Simulate data\ny  <- rnorm(n = 10, mean = 100, sd = 15)\nx1 <- rnorm(n = 10, mean =   0, sd =  1)\nx2 <- rnorm(n = 10, mean =  10, sd = 10)\nx3 <- rnorm(n = 10, mean =  20, sd =  5)\nn10 <- tibble(y, x1, x2, x3)\n```\n:::\n\n\n## Doing it \"by-hand\"\n\nNow let's say we want to add a new variable `xmean` to the tibble containing each observation's mean of `x1`, `x2`, and `x3`. \n\nWe can use `mutate()` and math to achieve this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 0 (works but inconvenient)\nn10 |> \n  mutate(xmean = (x1 + x2 + x3) / 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  8.28\n 2  85.3 -0.413  7.06  26.4 11.0 \n 3  71.9  0.562 22.2   15.9 12.9 \n 4  97.2  0.663 12.4   19.8 11.0 \n 5  90.5 -0.603  5.55  16.8  7.25\n 6 116.   0.698 -8.48  17.8  3.34\n 7  86.3  0.596  3.71  22.5  8.95\n 8 115.   0.452  1.39  25.6  9.16\n 9  94.0  0.897 25.1   24.9 17.0 \n10  93.0  0.572 37.4   19.4 19.1 \n```\n:::\n:::\n\n\n## A Failed Attempt\n\nBut this approach will be a hassle if you have any missing values or if you have lots of variables to average. Instead, if you are just learning \\{dplyr\\}, you would probably try to combine the `mean()` and `mutate()` functions as below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 1 (doesn't work)\nn10 |> \n  mutate(xmean = mean(c(x1, x2, x3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  10.8\n 2  85.3 -0.413  7.06  26.4  10.8\n 3  71.9  0.562 22.2   15.9  10.8\n 4  97.2  0.663 12.4   19.8  10.8\n 5  90.5 -0.603  5.55  16.8  10.8\n 6 116.   0.698 -8.48  17.8  10.8\n 7  86.3  0.596  3.71  22.5  10.8\n 8 115.   0.452  1.39  25.6  10.8\n 9  94.0  0.897 25.1   24.9  10.8\n10  93.0  0.572 37.4   19.4  10.8\n```\n:::\n:::\n\n\nHowever, you'll notice in the output above that the new `xmean` variable contains repetitions of a constant value. What is going on here? Basically, what `mutate()` did was take all the numbers in `x1`, `x2`, and `x3`, combine them into one long vector of 30 numbers, and send that vector to the `mean()` function. The `mean()` function then returns a single value---the mean of all 30 numbers---and tries to put that into the new column `xmean`. But because the column needs to be a vector of 10 numbers to fit into the tibble, that single value gets recycled (i.e., repeated 10 times). To verify this is what happened, we can do the operation by hand and see that we get the same number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(c(x1, x2, x3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.79233\n```\n:::\n:::\n\n\nSo, clearly `mutate()` is not doing what we intended it to do. \n\n## The `across()` approach\n\nLuckily, [dplyr 1.0.0](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-rowwise/) added some great features for doing operations within rows. The simplest version simply adds a call to the `rowwise()` function to our pipeline before the `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 2 (works but slow)\nn10 |> \n  rowwise() |>  \n  mutate(xmean = mean(c(x1, x2, x3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n# Rowwise: \n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  8.28\n 2  85.3 -0.413  7.06  26.4 11.0 \n 3  71.9  0.562 22.2   15.9 12.9 \n 4  97.2  0.663 12.4   19.8 11.0 \n 5  90.5 -0.603  5.55  16.8  7.25\n 6 116.   0.698 -8.48  17.8  3.34\n 7  86.3  0.596  3.71  22.5  8.95\n 8 115.   0.452  1.39  25.6  9.16\n 9  94.0  0.897 25.1   24.9 17.0 \n10  93.0  0.572 37.4   19.4 19.1 \n```\n:::\n:::\n\n\nThis did what we wanted it to do, despite the actual `mutate()` call being identical to what is was before! Pretty cool. We can even save some time by selecting the variables to include in the `mean()` operation automatically, instead of listing them out in the `c()` function. This isn't such a time-savings in this case with only three variables, but in settings with more variables it can really add up. To do so, we just need to use a [tidy selection](https://dplyr.tidyverse.org/reference/select.html) function; in this case, all the variables we want to include start with the letter \"x\" so let's use `starts_with()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 3 (doesn't work)\nn10 |> \n  rowwise()|> \n  mutate(xmean = mean(starts_with(\"x\")))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `xmean = mean(starts_with(\"x\"))`.\nℹ In row 1.\nCaused by error:\n! `starts_with()` must be used within a *selecting* function.\nℹ See <https://tidyselect.r-lib.org/reference/faq-selection-context.html> for\n  details.\n```\n:::\n:::\n\n\nShoot, that didn't work. But why not? Basically, the problem is that `mutate()` doesn't know what do to with selection functions like `starts_with()`. The error message basically says that we are in the \"wrong context\" for a selection function.\n\n## Tidy selection with `c_across()`\n\nLuckily, [dplyr 1.0.0](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-rowwise/) also added the `c_across()` function, which will allow us to change the context to one that does allow selection functions. The code below now works as intended, first selecting all the variables starting with \"x\" and then computing their row-wise means.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 4 (works but slow)\nn10 |> \n  rowwise() |> \n  mutate(xmean = mean(c_across(starts_with(\"x\"))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n# Rowwise: \n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  8.28\n 2  85.3 -0.413  7.06  26.4 11.0 \n 3  71.9  0.562 22.2   15.9 12.9 \n 4  97.2  0.663 12.4   19.8 11.0 \n 5  90.5 -0.603  5.55  16.8  7.25\n 6 116.   0.698 -8.48  17.8  3.34\n 7  86.3  0.596  3.71  22.5  8.95\n 8 115.   0.452  1.39  25.6  9.16\n 9  94.0  0.897 25.1   24.9 17.0 \n10  93.0  0.572 37.4   19.4 19.1 \n```\n:::\n:::\n\n\n## Remember to `ungroup()`\n\nThere are two things to note about `rowwise()`, however. First, it transformed our tibble into an implicitly \"grouped\" tibble, which is what allowed our `mutate()` function to calculate row-wise means instead of overall means (basically, it is treating each row as a separate group and calculating the means per group/row). However, after that `mutate()` call, the tibble remains grouped. This is handy if we want to continue doing row-wise operations, but how do we tell it to stop once we are done with row-wise operations and want to return to \"normal\" behavior? Let's see when this could be a problem; one example is if we want to calculate the maximum row-wise mean `xmean_max`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 5 (doesn't work)\nn10 |> \n  rowwise() |> \n  mutate(xmean = mean(c_across(starts_with(\"x\")))) |> \n  summarize(xmean_max = max(xmean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 1\n   xmean_max\n       <dbl>\n 1      8.28\n 2     11.0 \n 3     12.9 \n 4     11.0 \n 5      7.25\n 6      3.34\n 7      8.95\n 8      9.16\n 9     17.0 \n10     19.1 \n```\n:::\n:::\n\n\nHere we wanted to summarize over all values of `xmean` and expected a single maximum value. Instead we got the same 10 values back. What happened? Basically, our tibble was still implicitly grouped by row and the `summarize()` function respected that, calculating the maximum of each group/row. To avoid this behavior, we can add the `ungroup()` function to our pipeline (reverting the tibble back to a standard one without implicit grouping).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 6 (works but slow)\nn10 |> \n  rowwise() |> \n  mutate(xmean = mean(c_across(starts_with(\"x\")))) |> \n  ungroup() |>\n  summarize(xmean_max = max(xmean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  xmean_max\n      <dbl>\n1      19.1\n```\n:::\n:::\n\n\nNow we get the desired behavior, and so I am usually very careful to add `ungroup()` to my pipeline as soon as I am done with row-wise operations (otherwise you might end up with some unexpected problems). \n\n## Faster means with `rowMeans()`\n\nThe other thing to note about `rowwise()` is that it can be slow. With a small tibble like this, it doesn't matter much, but the difference could be meaningful for larger and more complex data. In these cases, you have some alternatives. This [blog post](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-rowwise/) describes some of them, but does not address the specific case of means, which is what I want to do the most in practice. A faster alternative in this case is to use the `rowMeans()` function. As you might imagine, this function takes in a numeric matrix or dataframe and returns the mean of each row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowMeans(n10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 30.89482 29.57077 27.64172 32.52192 28.06156 31.59763 28.28442 35.62799\n [9] 36.23378 37.56994\n```\n:::\n:::\n\n\nBut we want to exclude the `y` variable and append it to the `n10` tibble. How to do so? We might reasonably try to put it into `mutate()` like we did with `mean()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 7 (doesn't work)\nn10 |> \n  mutate(xmean = rowMeans(c(x1, x2, x3)))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `xmean = rowMeans(c(x1, x2, x3))`.\nCaused by error in `rowMeans()`:\n! 'x' must be an array of at least two dimensions\n```\n:::\n:::\n\n\nBut here we run into a problem. `rowMeans()` is expecting a numeric matrix or data frame, but is being provided with a vector of 30 numbers again (as in Example 1). Thus, it doesn't have rows to calculate means within and returns an error. We can solve this by transforming the vector to a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 8 (works but inconvenient)\nn10 |> \n  mutate(xmean = rowMeans(matrix(c(x1, x2, x3), ncol = 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  8.28\n 2  85.3 -0.413  7.06  26.4 11.0 \n 3  71.9  0.562 22.2   15.9 12.9 \n 4  97.2  0.663 12.4   19.8 11.0 \n 5  90.5 -0.603  5.55  16.8  7.25\n 6 116.   0.698 -8.48  17.8  3.34\n 7  86.3  0.596  3.71  22.5  8.95\n 8 115.   0.452  1.39  25.6  9.16\n 9  94.0  0.897 25.1   24.9 17.0 \n10  93.0  0.572 37.4   19.4 19.1 \n```\n:::\n:::\n\n\nBut [dplyr 1.1.0](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/) added a way to streamline this kind of thing. We can use the new `pick()` function to create this context and avoid the need for the dot operator. Note that we using `pick()` here instead of `c_across()` because the latter is for working within rows (in combination with `rowwise()`) and here we want the row-wise operations to be handled by `rowMeans()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 11 (works and convenient and fast)\nn10 |> \n  mutate(xmean = rowMeans(pick(starts_with(\"x\"))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 5\n       y     x1    x2    x3 xmean\n   <dbl>  <dbl> <dbl> <dbl> <dbl>\n 1  98.7  0.327  5.88  18.6  8.28\n 2  85.3 -0.413  7.06  26.4 11.0 \n 3  71.9  0.562 22.2   15.9 12.9 \n 4  97.2  0.663 12.4   19.8 11.0 \n 5  90.5 -0.603  5.55  16.8  7.25\n 6 116.   0.698 -8.48  17.8  3.34\n 7  86.3  0.596  3.71  22.5  8.95\n 8 115.   0.452  1.39  25.6  9.16\n 9  94.0  0.897 25.1   24.9 17.0 \n10  93.0  0.572 37.4   19.4 19.1 \n```\n:::\n:::\n\n\nTo test the speed of each approach, we can use the [microbenchmark](https://github.com/joshuaulrich/microbenchmark/) package, which will precisely time each approach over multiple iterations (in this case, 100). Let's wrap up by testing the speech of each approach with increasingly large data sets.\n\n\n::: {.cell hash='index_cache/html/speedtest_9d26231672f36fe92d233f90c9197b45'}\n\n```{.r .cell-code}\n# Create function wrappers so the microbenchmark output is prettier\nA_rowwise <- function(.data) { \n  .data |> \n    rowwise() |> \n    mutate(xmean = mean(c_across(starts_with(\"x\")))) |> \n    ungroup()\n}\n\nB_rowMeans <- function(.data) { \n  .data |> \n    mutate(xmean = rowMeans(pick(starts_with(\"x\"))))\n}\n\n# Simulate larger datasets\nn100 <- n10 |> slice(rep(1:n(), times = 10))\nn1000 <- n100 |> slice(rep(1:n(), times = 10))\nn10000 <- n1000 |> slice(rep(1:n(), times = 10))\n\n# Perform microbenchmarking\nspeedtest <- \n  microbenchmark(\n    A_rowwise(n10),\n    A_rowwise(n100),\n    A_rowwise(n1000),\n    A_rowwise(n10000),\n    B_rowMeans(n10),\n    B_rowMeans(n100), \n    B_rowMeans(n1000),\n    B_rowMeans(n10000),\n    times = 100L\n  )\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Approach </th>\n   <th style=\"text-align:right;\"> mean_time_ms </th>\n   <th style=\"text-align:right;\"> sd_time_ms </th>\n   <th style=\"text-align:right;\"> min_time_ms </th>\n   <th style=\"text-align:right;\"> max_time_ms </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> A_rowwise(n10) </td>\n   <td style=\"text-align:right;\"> 12.025 </td>\n   <td style=\"text-align:right;\"> 1.279 </td>\n   <td style=\"text-align:right;\"> 10.999 </td>\n   <td style=\"text-align:right;\"> 18.844 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A_rowwise(n100) </td>\n   <td style=\"text-align:right;\"> 90.208 </td>\n   <td style=\"text-align:right;\"> 4.903 </td>\n   <td style=\"text-align:right;\"> 84.182 </td>\n   <td style=\"text-align:right;\"> 126.810 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A_rowwise(n1000) </td>\n   <td style=\"text-align:right;\"> 878.763 </td>\n   <td style=\"text-align:right;\"> 42.149 </td>\n   <td style=\"text-align:right;\"> 835.994 </td>\n   <td style=\"text-align:right;\"> 1053.001 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> A_rowwise(n10000) </td>\n   <td style=\"text-align:right;\"> 8767.835 </td>\n   <td style=\"text-align:right;\"> 217.319 </td>\n   <td style=\"text-align:right;\"> 8500.523 </td>\n   <td style=\"text-align:right;\"> 10053.289 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> B_rowMeans(n10) </td>\n   <td style=\"text-align:right;\"> 2.852 </td>\n   <td style=\"text-align:right;\"> 0.530 </td>\n   <td style=\"text-align:right;\"> 2.470 </td>\n   <td style=\"text-align:right;\"> 7.109 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> B_rowMeans(n100) </td>\n   <td style=\"text-align:right;\"> 2.875 </td>\n   <td style=\"text-align:right;\"> 0.577 </td>\n   <td style=\"text-align:right;\"> 2.451 </td>\n   <td style=\"text-align:right;\"> 5.720 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> B_rowMeans(n1000) </td>\n   <td style=\"text-align:right;\"> 2.865 </td>\n   <td style=\"text-align:right;\"> 0.501 </td>\n   <td style=\"text-align:right;\"> 2.458 </td>\n   <td style=\"text-align:right;\"> 5.665 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> B_rowMeans(n10000) </td>\n   <td style=\"text-align:right;\"> 2.972 </td>\n   <td style=\"text-align:right;\"> 0.540 </td>\n   <td style=\"text-align:right;\"> 2.575 </td>\n   <td style=\"text-align:right;\"> 5.646 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(speedtest)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/stplot-1.png){width=860px}\n:::\n:::\n\n\nThe speed difference between approaches grows with the number of observations and becomes quite noticeable at 1000 observations or more. So, although I think it is worth learning the new `rowwise()` and `c_across()` functions, in settings where observations are many and speed in paramount, it may be worthwhile to learn \"parallel\" functions such as `rowMeans()`, `rowSums()`, `pmin()`, `pmax()`, and `paste()`.\n\n## Session Info\n\n<p><details><summary>Click here for session info</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.3 (2023-03-15 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 22624)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] kableExtra_1.3.4     knitr_1.41           microbenchmark_1.4.9\n [4] forcats_0.5.2        stringr_1.5.0        dplyr_1.1.0         \n [7] purrr_1.0.1          readr_2.1.3          tidyr_1.2.1         \n[10] tibble_3.1.8         ggplot2_3.4.0        tidyverse_1.3.2     \n\nloaded via a namespace (and not attached):\n [1] svglite_2.1.1       lubridate_1.9.0     assertthat_0.2.1   \n [4] digest_0.6.31       utf8_1.2.2          R6_2.5.1           \n [7] cellranger_1.1.0    backports_1.4.1     reprex_2.0.2       \n[10] evaluate_0.20       highr_0.10          httr_1.4.4         \n[13] pillar_1.8.1        rlang_1.1.0         googlesheets4_1.0.1\n[16] readxl_1.4.1        rstudioapi_0.14     rmarkdown_2.19     \n[19] webshot_0.5.4       googledrive_2.0.0   htmlwidgets_1.6.2  \n[22] munsell_0.5.0       broom_1.0.2         compiler_4.2.3     \n[25] modelr_0.1.10       xfun_0.36           systemfonts_1.0.4  \n[28] pkgconfig_2.0.3     htmltools_0.5.4     tidyselect_1.2.0   \n[31] viridisLite_0.4.1   fansi_1.0.3         crayon_1.5.2       \n[34] tzdb_0.3.0          dbplyr_2.3.0        withr_2.5.0        \n[37] grid_4.2.3          jsonlite_1.8.4      gtable_0.3.1       \n[40] lifecycle_1.0.3     DBI_1.1.3           magrittr_2.0.3     \n[43] scales_1.2.1        cli_3.6.0           stringi_1.7.12     \n[46] farver_2.1.1        renv_0.16.0         fs_1.5.2           \n[49] xml2_1.3.3          ellipsis_0.3.2      generics_0.1.3     \n[52] vctrs_0.6.0         tools_4.2.3         glue_1.6.2         \n[55] hms_1.1.2           fastmap_1.1.0       yaml_2.3.6         \n[58] timechange_0.2.0    colorspace_2.0-3    gargle_1.2.1       \n[61] rvest_1.0.3         haven_2.5.1        \n```\n:::\n:::\n\n</details></p>\n\n## Notes / References\n\n- \\[1\\] [dplyr vignette: Row-wise operations](https://dplyr.tidyverse.org/dev/articles/rowwise.html)\n\n- \\[2\\] [dplyr 1.1.0: pick(), reframe(), arrange()](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/)\n\n- \\[3\\] [dplyr 1.0.0: working within rows](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-rowwise/)\n\n- \\[4\\] [dplyr issue \\#4544](https://github.com/tidyverse/dplyr/issues/4544)\n\n- *Note:* This is an update of an [older blog post](https://jmgirard.com/rowwise-means/) on my personal website.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}